import { r as __toESM, t as require_react } from "./react-4Wr0HZ5l.js";

//#region node_modules/.pnpm/react-confetti-boom@2.0.1_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/react-confetti-boom/lib/index.esm.js
var import_react = /* @__PURE__ */ __toESM(require_react());
function styleInject(css, ref) {
	if (ref === void 0) ref = {};
	var insertAt = ref.insertAt;
	if (!css || typeof document === "undefined") return;
	var head = document.head || document.getElementsByTagName("head")[0];
	var style = document.createElement("style");
	style.type = "text/css";
	if (insertAt === "top") if (head.firstChild) head.insertBefore(style, head.firstChild);
	else head.appendChild(style);
	else head.appendChild(style);
	if (style.styleSheet) style.styleSheet.cssText = css;
	else style.appendChild(document.createTextNode(css));
}
var css_248z = ".index-module_canvas__H2w7d {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n}";
var styles = { "canvas": "index-module_canvas__H2w7d" };
styleInject(css_248z);
var randomNumBetween = function(min, max) {
	return Math.random() * (max - min) + min;
};
var hexToRgb = function(hex) {
	return {
		r: parseInt(hex.slice(1, 3), 16),
		g: parseInt(hex.slice(3, 5), 16),
		b: parseInt(hex.slice(5, 7), 16)
	};
};
var Particle = function() {
	function Particle$1(x, y, deg, colors, shapes, shapeSize, spread, launchSpeed, opacityDelta) {
		if (deg === void 0) deg = 0;
		if (shapes === void 0) shapes = ["circle", "square"];
		if (shapeSize === void 0) shapeSize = 12;
		if (spread === void 0) spread = 30;
		if (launchSpeed === void 0) launchSpeed = 1;
		if (opacityDelta === void 0) opacityDelta = .004;
		this.x = x * window.innerWidth;
		this.y = y * window.innerHeight;
		this.width = shapeSize;
		this.height = shapeSize;
		this.theta = Math.PI / 180 * randomNumBetween(deg - spread, deg + spread);
		this.radius = randomNumBetween(20 * launchSpeed, 70 * launchSpeed);
		this.vx = this.radius * Math.cos(this.theta);
		this.vy = this.radius * Math.sin(this.theta);
		this.xFriction = .9;
		this.yFriction = .87;
		this.gravity = randomNumBetween(.5, .6);
		this.opacity = 1;
		this.opacityDelta = opacityDelta;
		this.rotate = randomNumBetween(0, 360);
		this.widthDelta = randomNumBetween(0, 360);
		this.heightDelta = randomNumBetween(0, 360);
		this.rotateDelta = randomNumBetween(-1, 1);
		this.colors = colors;
		this.color = hexToRgb(this.colors[Math.floor(randomNumBetween(0, this.colors.length))]);
		this.shapes = shapes;
		this.shape = this.shapes[Math.floor(randomNumBetween(0, this.shapes.length))];
		this.swingOffset = randomNumBetween(0, Math.PI * 2);
		this.swingSpeed = Math.random() * .05 + .01;
		this.swingAmplitude = randomNumBetween(.1, .2);
	}
	Particle$1.prototype.update = function() {
		this.vx *= this.xFriction;
		this.vy *= this.yFriction;
		this.vy += this.gravity;
		this.vx += Math.sin(this.swingOffset) * this.swingAmplitude;
		this.x += this.vx;
		this.y += this.vy;
		this.opacity -= this.opacityDelta;
		this.widthDelta += 2;
		this.heightDelta += 2;
		this.rotate += this.rotateDelta;
		this.swingOffset += this.swingSpeed;
	};
	Particle$1.prototype.drawSquare = function(ctx) {
		ctx.fillRect(this.x, this.y, this.width * Math.cos(Math.PI / 180 * this.widthDelta), this.height * Math.sin(Math.PI / 180 * this.heightDelta));
	};
	Particle$1.prototype.drawCircle = function(ctx) {
		ctx.beginPath();
		ctx.ellipse(this.x, this.y, Math.abs(this.width * Math.cos(Math.PI / 180 * this.widthDelta)) / 2, Math.abs(this.height * Math.sin(Math.PI / 180 * this.heightDelta)) / 2, 0, 0, 2 * Math.PI);
		ctx.fill();
		ctx.closePath();
	};
	Particle$1.prototype.draw = function(ctx) {
		var translateXAlpha = this.width * 1.3;
		var translateYAlpha = this.height * 1.3;
		ctx.translate(this.x + translateXAlpha, this.y + translateYAlpha);
		ctx.rotate(Math.PI / 100 * this.rotate);
		ctx.translate(-(this.x + translateXAlpha), -(this.y + translateYAlpha));
		ctx.fillStyle = "rgba(".concat(this.color.r, ", ").concat(this.color.g, ", ").concat(this.color.b, ", ").concat(this.opacity, ")");
		if (this.shape === "square") this.drawSquare(ctx);
		if (this.shape === "circle") this.drawCircle(ctx);
		ctx.resetTransform();
	};
	return Particle$1;
}();
var INTERVAL = 1e3 / 60;
function Confetti(props) {
	var _a = props.mode, mode = _a === void 0 ? "boom" : _a, _b = props.particleCount, particleCount = _b === void 0 ? 30 : _b, _c = props.shapeSize, shapeSize = _c === void 0 ? 12 : _c, _d = props.colors, colors = _d === void 0 ? [
		"#ff577f",
		"#ff884b",
		"#ffd384",
		"#fff9b0"
	] : _d, className = props.className, style = props.style;
	var _e = props.mode === "boom" || props.mode === void 0 ? props : {
		effectInterval: 1,
		effectCount: Infinity
	}, _f = _e.x, x = _f === void 0 ? .5 : _f, _g = _e.y, y = _g === void 0 ? .5 : _g, _h = _e.deg, deg = _h === void 0 ? 270 : _h, _j = _e.spreadDeg, spreadDeg = _j === void 0 ? 30 : _j, _k = _e.effectInterval, effectInterval = _k === void 0 ? 3e3 : _k, _l = _e.effectCount, effectCount = _l === void 0 ? 1 : _l, _m = _e.launchSpeed, launchSpeed = _m === void 0 ? 1 : _m, _o = _e.opacityDeltaMultiplier, opacityDeltaMultiplier = _o === void 0 ? 1 : _o;
	var _p = (props.mode === "fall" ? props : {}).fadeOutHeight, fadeOutHeight = _p === void 0 ? .8 : _p;
	var canvasRef = (0, import_react.useRef)(null);
	var ctxRef = (0, import_react.useRef)();
	var particlesRef = (0, import_react.useRef)([]);
	var animationFrameRef = (0, import_react.useRef)(0);
	var effectCountRef = (0, import_react.useRef)(0);
	var init = (0, import_react.useCallback)(function() {
		var canvas = canvasRef.current;
		var ctx = canvas === null || canvas === void 0 ? void 0 : canvas.getContext("2d");
		if (!canvas || !ctx) return;
		ctxRef.current = ctx;
		var canvasWidth = window.innerWidth;
		var canvasHeight = window.innerHeight;
		canvas.width = canvasWidth;
		canvas.height = canvasHeight;
	}, []);
	var createConfetti = (0, import_react.useCallback)(function() {
		var isFallMode = mode === "fall";
		var effectiveCount = isFallMode ? particleCount / 30 : particleCount;
		var effectiveX = isFallMode ? randomNumBetween(0, 1) : x;
		var effectiveY = isFallMode ? randomNumBetween(-.1, -.3) : y;
		var effectiveDeg = isFallMode ? 270 : deg;
		var effectiveSpreadDeg = isFallMode ? 0 : spreadDeg;
		var effectiveLaunchSpeed = isFallMode ? 0 : launchSpeed;
		var effectiveOpacityDelta = isFallMode ? 3.4 / fadeOutHeight / window.innerHeight : .004 * Math.max(.1, opacityDeltaMultiplier);
		for (var i = 0; i < effectiveCount; i += 1) particlesRef.current.push(new Particle(effectiveX, effectiveY, effectiveDeg, colors, ["circle", "square"], shapeSize, effectiveSpreadDeg, effectiveLaunchSpeed, effectiveOpacityDelta));
	}, [
		mode,
		x,
		y,
		deg,
		colors,
		shapeSize,
		spreadDeg,
		launchSpeed,
		particleCount,
		fadeOutHeight,
		opacityDeltaMultiplier
	]);
	var render = (0, import_react.useCallback)(function() {
		if (!ctxRef.current) return;
		var now;
		var delta;
		var then = Date.now();
		var effectDelta;
		var effectThen = Date.now() - effectInterval;
		var frame = function() {
			var canvas = canvasRef.current;
			if (!ctxRef.current) return;
			if (!canvas) return;
			animationFrameRef.current = requestAnimationFrame(frame);
			now = Date.now();
			delta = now - then;
			effectDelta = now - effectThen;
			if (delta < INTERVAL) return;
			ctxRef.current.clearRect(0, 0, canvas.width, canvas.height);
			if (effectDelta > effectInterval && effectCountRef.current < effectCount) {
				createConfetti();
				effectThen = now - effectDelta % effectInterval;
				effectCountRef.current += 1;
			}
			var particles = particlesRef.current;
			for (var i = particles.length - 1; i >= 0; i -= 1) {
				var p = particles[i];
				p.update();
				p.draw(ctxRef.current);
				var canvasHeight = (canvas === null || canvas === void 0 ? void 0 : canvas.height) || 0;
				if (p.opacity <= 0 || p.y > canvasHeight) particles.splice(particles.indexOf(p), 1);
			}
			then = now - delta % INTERVAL;
			if (effectCountRef.current >= effectCount && particles.length === 0) cancelAnimationFrame(animationFrameRef.current);
		};
		animationFrameRef.current = requestAnimationFrame(frame);
	}, [
		effectInterval,
		effectCount,
		createConfetti
	]);
	(0, import_react.useEffect)(function() {
		init();
		render();
		return function() {
			if (animationFrameRef.current) cancelAnimationFrame(animationFrameRef.current);
		};
	}, [init, render]);
	(0, import_react.useEffect)(function() {
		effectCountRef.current = 0;
	}, [effectCount]);
	return import_react.createElement("canvas", {
		className: [styles.canvas, className].filter(Boolean).join(" "),
		ref: canvasRef,
		style
	});
}

//#endregion
export { Confetti as default };
//# sourceMappingURL=react-confetti-boom.js.map